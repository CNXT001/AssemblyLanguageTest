# **王爽《汇编语言》第三版检测点答案**

>注：该答案为个人整理所得，如有纰漏，欢迎指正。
## 检测点1.1
---

### 问题
（1） 1个CPU的寻址能力为8KB，那么他的地址总线的宽度为【 】。  
（2） 1KB的存储器有 【 】个存储单元。存储单元编号从【 】到【 】。  
（3） 1KB的存储器可以存储【 】个bit，【 】个Byte。  
（4） 1GB、1MB、1KB分别是【 】Byte。  
（5） 8080、8088、8026、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为：【 】(KB)、【 】(MB)、【 】(MB)、【 】(GB)。  
（6） 8080、8088、8086、8026、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：【 】(B)、【 】(B)、【 】(B)、【 】(B)、【 】(B)。  
（7） 从内存中读取1024字节的数据，8086至少要读【 】次，80386至少要读【 】次。  
（8）在存储器中，数据和程序以【 】形式存放。

### 答案
（1） 1个CPU的寻址能力为8KB，那么他的地址总线的宽度为【 **13** 】。  
（2） 1KB的存储器有 【 **1024** 】个存储单元。存储单元编号从【 **0000** 】到【 **1023** 】。  
（3） 1KB的存储器可以存储【 **1024 x 8** 】个bit，【 **1024** 】个Byte。  
（4） 1GB、1MB、1KB分别是【**1024x1024x1024、1024x1024、1024** 】Byte。  
（5） 8080、8088、8026、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为：【 **64** 】(KB)、【 **1** 】(MB)、【 **16** 】(MB)、【 **4** 】(GB)。  
（6） 8080、8088、8086、8026、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：【 **1** 】(B)、【 **1** 】(B)、【 **2** 】(B)、【 **2** 】(B)、【 **4** 】(B)。  
（7） 从内存中读取1024字节的数据，8086至少要读【 **512** 】次，80386至少要读【 **256** 】次。  
（8）在存储器中，数据和程序以【 **二进制码** 】形式存放。

### 解析
略。

## 检测点2.1
---

### 问题
（1） 写出每条汇编指令执行后相关寄存器中的值。  

| 指令 | 寄存器 |
|--|--|
| mov ax, 62627 | AX = __ |
| mov ah, 31H | AX = __ |
| mov al, 23H | AX = __ |
| add ax, ax | AX = __ |
| mov bx, 826CH | BX = __ |
| mov cx, ax | CX = __ |
| mov ax, bx | AX = __ |
| add ax, bx | AX = __ |
| mov al, bh | AX = __ |
| mov ah, bl | AX = __ |
| mov ah, ah | AX = __ |
| add al, 6 | AX = __ |
| add al, al | AX = __ |
| mov ax, cx | AX = __ |

（2） 只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。

### 答案

（1） 写出每条汇编指令执行后相关寄存器中的值。  

| 指令 | 寄存器 |
|--|--|
| mov ax, 62627 | AX = F4A3H |
| mov ah, 31H | AX = 31A3H |
| mov al, 23H | AX = 3123H |
| add ax, ax | AX = 6246H |
| mov bx, 826CH | BX = 826CH |
| mov cx, ax | CX = 6246H |
| mov ax, bx | AX = 826CH |
| add ax, bx | AX = 04D8H |
| mov al, bh | AX = 0482H |
| mov ah, bl | AX = 6C82H |
| add ah, ah | AX = D882H |
| add al, 6 | AX = D888H |
| add al, al | AX = D890H |
| mov ax, cx | AX = 6246H |

（2） 只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。
```
mov ax, 2H
add ax, ax
add ax, ax
add ax, ax
```

### 解析
略。

## 检测点2.2
---

### 问题
（1） 给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为【 】到【 】。  
（2） 有一数据存放在内存20000H单元中，现给定段地址为SA,若想用偏移地址寻到此单元。则SA应满足的条件是：最小为【 】，最大为【】。  
提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元。

### 答案
（1） 给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为【 **00010H** 】到【 **1000FH** 】。  
（2） 有一数据存放在内存20000H单元中，现给定段地址为SA,若想用偏移地址寻到此单元。则SA应满足的条件是：最小为【 **1001H** 】，最大为【 **2000H** 】。  

### 解析
（1）偏移地址最小为 0000H，最大为FFFFH。按（段地址*16 + 偏移地址）计算可得。  
（2）偏移地址最小为 0000H，最大为FFFFH。偏移地址取最小值0000H时，段地址最大为2000H。偏移地址取最大值FFFFH时，段地址为：(20000H - FFFFH)/16 = 10001H/16 = 1000H。
因为段地址要满足可以寻址到20000H单元的条件，所以段地址取1001H。

## 检测点2.3
---

### 问题
下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？  
mov ax, bx  
sub ax, ax  
jmp ax
### 答案
三条指令执行后，CPU共计4次修改IP。  

第1次是在mov ax, bx指令加载至指令缓冲器后。  
第2次是在sub ax, ax指令加载至指令缓冲器后。  
第3次是在jmp ax指令加载至指令缓冲器后。  
第4次是在jmp ax指令执行完毕后。  

最后IP中的值是0000H。
### 解析
8086CPU的工作过程可以简要描述如下：  
（1） 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；  
（2） IP = IP + 所读取指令的长度，从而指向下一条指令；  
（3） 执行指令。转到步骤（1），重复这个过程。

“Jmp 段地址：偏移地址” 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP。  
“Jmp 偏移地址” 指令的功能为：用寄存器中的值修改IP。

## 检测点11.1
---
### 问题：

写出下面每条指令执行后，ZF、PF、SF等标志位的值。

|指令|ZF（零标志位）|PF（奇偶标志位）|SF（符号标志位）|
|:-||||
|sub al, al|ZF = ___|PF = ___|SF = ___|
|mov al, 1|ZF = ___|PF = ___|SF = ___|
|push ax|ZF = ___|PF = ___|SF = ___|
|pop bx|ZF = ___|PF = ___|SF = ___|
|add al, bl|ZF = ___|PF = ___|SF = ___|
|add al, 10|ZF = ___|PF = ___|SF = ___|
|mul al|ZF = ___|PF = ___|SF = ___|

### 答案：

|指令|ZF（零标志位）|PF（奇偶标志位）|SF（符号标志位）|
|:-||||
|sub al, al|ZF = 1|PF = 1|SF = 0|
|mov al, 1 |ZF = 1|PF = 1|SF = 0|
|push ax   |ZF = 1|PF = 1|SF = 0|
|pop bx    |ZF = 1|PF = 1|SF = 0|
|add al, bl|ZF = 0|PF = 0|SF = 0|
|add al, 10|ZF = 0|PF = 1|SF = 0|
|mul al    |ZF = 0|PF = 1|SF = 0|

### 解析：

注意，在8086CPU的指令集中，有的指令是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（逻辑运算，或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。

## 检测点11.2
---
### 问题：

写出下面每条指令执行后，ZF、PF、SF、CF、OP等标志位的值。

|指令|CF|OF|SF|ZF|PF
|-|-|-|-|-|-|
|sub al, al   | | | | | |
|mov al, 10H  | | | | | |
|add al, 90H  | | | | | |
|mov al, 80H  | | | | | |
|add al, 80H  | | | | | |
|mov al, 0FCH | | | | | |
|add al, 05H  | | | | | |
|add al, 7DH  | | | | | |
|add al, 0BH  | | | | | ||

### 答案：

|指令|CF|OF|SF|ZF|PF
|-|-|-|-|-|-|
|sub al, al   |0 |0 |0 |1 |1 |
|mov al, 10H  |0 |0 |0 |1 |1 |
|add al, 90H  |0 |0 |1 |0 |1 |
|mov al, 80H  |0 |0 |1 |0 |1 |
|add al, 80H  |1 |1 |0 |1 |1 |
|mov al, 0FCH |1 |1 |0 |1 |1 |
|add al, 05H  |1 |0 |0 |0 |0 |
|add al, 7DH  |1 |0 |0 |0 |0 |
|add al, 0BH  |0 |1 |1 |0 |1 |

### 解析：

**CF(CarryFlag)** ：进位标志位，记录**无符号运算**结果是否有进位/借位。如果有进位或者借位，则CF = 1。

**OF(OverflowFlag)**：溢出标记位，记录**有符号运算**结果是否溢出，如果溢出，则OF = 1。

**SF(SignFlag)**：符号标记位，记录有符号运算结果，如果是有符号运算结果为负数时，SF = 1。

**ZF(ZeroFlag)**：零标记位，记录运算结果是否为0，如果运算结果为0，则ZF = 1。

**PF(ParityFlag)**：奇偶标记位，记录运算结果二进制数中1的个数是否是偶数，如果1的个数为偶数，则PF = 1。

同时需要注意mov、push、pop等传送指令对flag没有影响。

## 检测点11.3
---
### 问题
（1）补全下面的程序，统计F000:0处32个字节中，大小在[32,128]的数据的个数。

```
    mov ax, 0f000h
    mov ds, ax

    mov bx, 0
    mov dx, 0
    mov cx, 32
s:  mov al, [bx]
    cmp al, 32
    ______________
    cmp al, 128
    ______________
    inc dx
s0: inc bx
    loop s
```
（2）补全下面的程序，统计F000:0处32个字节中，大小在(32, 128)的数据的个数。
```
    mov ax, 0f000h
    mov ds, ax

    mov bx, 0
    mov dx, 0
    mov cx, 32
s:  mov al, [bx]
    cmp al, 32
    ______________
    cmp al, 128
    ______________
    inc dx
s0: inc bx
    loop s
```
### 答案
（1）

```
...
jb so
...
ja so
...
```

（2）

```
...
jna so
...
jnb so
...
```


### 解析
jb：低于则转移

ja：高于则转移

jna：不高于则转移

jnb：不低于则转移

## 检测点 11.4
---
### 问题
下面的程序执行后：（ax）= ?

```
mov ax, 0
push ax
popf
mov ax, 0fff0h
add ax, 0010h
push f
pop ax
and al, 11000101B
and ah, 00001000B
```
### 答案
(ax) = 0000 0000 0100 0101

### 解析
```
mov ax, 0fff0h
add ax, 0010h
```
这两句代码执行过后，ax = 0000 0000 0000 0000。有进位，无溢出，结果为0。
所以各标志位的值分别为：
```
zf = 1
pf = 1
sf = 0
cf = 1
of = 0
df = 0
```

## 检测点12.1
---
### 问题
（1）用Debug查看内存，情况如下：
```
0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00
```
则3号中断源对应的中断处理程序的入口地址为：【 】。

（2）存储N号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为：【 】。
存储N号中断源对应的中断处理程序入口的段地址的内存单元的地址为：【 】。

### 答案
（1）0070:018B

（2）4N, 4N+2

### 解析
（1）在中断向量表中，一个中断向量占两个字，也即四个字节。高地址字存放段地址，低地址字存放偏移地址。

（2）同上。
